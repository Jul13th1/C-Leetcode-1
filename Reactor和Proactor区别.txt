区别：
    Proactor 和 Reactor 模式都是设计用于处理高并发 I/O 操作的事件驱动模型，它们主要应用于网络编程和异步 I/O 中，特别是在处理大量并发客户端请求时。
这两者的区别在于事件处理的方式以及它们如何与 I/O 操作的执行和完成进行交互。

1.Reactor模式：
        Reactor 模式通常用于同步 I/O 操作。其核心思想是：当事件发生时（例如，I/O 操作就绪），主线程会监听并分发这些事件，并将它们分派给具体的处理程序（Handler）。
    在这种模式下，I/O 操作由应用程序负责处理，即应用程序自己控制何时发起 I/O 操作。
    Reactor 模式的工作流程：
        1.事件循环（Event Loop）：Reactor 服务器不断等待和监听事件（如客户端连接、数据可读或可写等）。
        2.事件检测：当一个 I/O 事件（例如，某个 socket 可读或可写）发生时，Reactor 会通知相关的 Handler。
        3.I/O 操作：Handler 接收到事件后，它会调用同步 I/O 操作来处理数据。
    总结：在 Reactor 模式中，I/O 操作是同步的，Reactor 只负责事件的分发和调度，I/O 操作由应用程序的 Handler 负责执行。

2.Proactor 模式：
        Proactor 模式与 Reactor 模式的主要区别在于，I/O 操作的执行和完成是由操作系统或 I/O 线程来处理的，而不是由应用程序直接控制。
    应用程序只需要发出请求，并在 I/O 操作完成后进行相应的处理。
    Proactor 模式的工作流程：
        1.事件循环：Proactor 会监听和等待 I/O 完成事件（例如，数据已准备好，操作完成等）。
        2.异步 I/O 请求：应用程序发起异步 I/O 请求，操作系统负责执行实际的 I/O 操作。
        3.I/O 完成通知：操作系统在完成 I/O 操作后，会通知应用程序。
        4.事件处理：应用程序收到 I/O 完成通知后，调用相应的处理函数。
      总结：在 Proactor 模式中，I/O 操作是异步的，应用程序只需请求操作，I/O 任务的执行和完成通知由操作系统或 I/O 线程负责，应用程序通过回调来处理 I/O 完成后的操作。

核心区别总结：
        特性	                                 Reactor 模式	                                    Proactor 模式
I/O 操作的执行者	                        应用程序负责执行 I/O 操作（同步）	                操作系统或 I/O 线程负责执行 I/O 操作（异步）
I/O 操作的性质	                                    同步 I/O 操作	                                    异步 I/O 操作
事件处理的触发方式	                    当 I/O 事件就绪时，触发事件处理（例如数据可读或可写）	 当 I/O 操作完成时，触发事件处理（例如数据已准备好）
适用场景	                       适合高并发的同步 I/O 操作场景，如多路复用模型（select、epoll）	适合高并发的异步 I/O 操作场景，如基于操作系统提供的异步 I/O
控制权	                                应用程序需要在事件处理时主动发起 I/O 操作	            操作系统主动执行 I/O 操作，应用程序只处理完成后的结果


具体应用场景：
    Reactor 模式    更适用于高并发的 同步 I/O 操作，典型的应用场景包括基于 select、poll 或 epoll 等的网络服务器或客户端，它们使用单个线程或少量线程管理多个连接，处理多个并发事件。
    Proactor 模式   更适用于 异步 I/O 操作，典型应用场景是高并发的网络应用（如大规模文件传输、数据库查询等），它们依赖操作系统提供的异步 I/O 支持，最大化地避免了线程阻塞。

Reactor 模式 处理的是“事件就绪”，应用程序在事件就绪时会主动进行 I/O 操作（同步）。
Proactor 模式 处理的是“事件完成”，I/O 操作由操作系统处理，应用程序只需要处理 I/O 完成后发生的事件