C++ 部分笔记

1.Map扩容是怎么做到的？
答：std::map 是一个基于红黑树的关联容器，它的扩容过程与 std::vector 等动态数组容器的扩容有所不同。
    std::map 使用红黑树来存储键值对。在插入新元素时，它会根据键的顺序将元素插入到树中。
    因为红黑树的结构是动态的，它可以根据需要自动调整和扩展，而不需要像数组那样进行“扩容”。
        map的插入操作：
        通过比较键值找到正确的插入位置。
        创建一个新的节点，并将其链接到树中。
        可能会进行旋转操作以维持红黑树的性质。

2.HashMap扩容机制，为什么每次扩容两倍？
答：达到某个阈值时，能够保持良好的性能，主要体现在插入和查找操作的时间复杂度
    当元素数量超过桶数的 75% 时，HashMap 会触发扩容
     为什么扩容两倍?
     (1)减少冲突：通过将桶的数量翻倍，可以有效地减少哈希冲突
     (2)性能优化：扩容后，查找和插入操作的平均时间复杂度可以保持在 O(1)
     (3)空间效率：扩容到两倍的大小通常能够在一定程度上保持负载因子在可接受范围内，减少频繁扩容带来的性能开销

3.线程的run()和start()有什么区别？
    （1）run() 方法：
        作用：run() 方法是线程的执行体，包含了线程执行时要执行的代码。如果你直接调用 run() 方法，它只是作为普通方法执行，而不会创建新线程。
        线程状态：调用 run() 方法不会改变线程的状态，它会在调用它的线程（通常是主线程）中执行。
        示例：如果你直接调用 run()，则不会实现并发，而是顺序执行。
    （2）start() 方法
        作用：调用 start() 方法会启动一个新线程。它会调用 run() 方法，但这个过程是在新线程中执行的。
        线程状态：当 start() 被调用时，线程会从“新建”状态变为“就绪”状态，等待操作系统调度来执行。
        示例：你可以通过调用 start() 来并行执行任务。

4.C++为什么HashMap链表要转为红黑树?
    在 C++ 的 std::unordered_map 中，当桶内的链表长度超过一定阈值时，链表可以转化为红黑树。这种设计主要是为了提高性能，特别是在处理哈希冲突的情况下。以下是几个主要原因:
    (1)查找效率 
        性能改善：链表的查找时间复杂度是 O(n)，而红黑树的查找时间复杂度是 O(log n)。在存在大量冲突时，转化为红黑树可以显著提升查找效率。
    (2)冲突管理
        冲突处理：当多个元素映射到同一个桶中，链表会增长。如果链表过长，性能会受到影响。通过将链表转换为红黑树，能够有效控制冲突带来的性能下降。
    (3)自平衡特性
        红黑树的自平衡：红黑树是一种自平衡的二叉搜索树，插入和删除操作后会自动调整，以保持 O(log n) 的高度。这可以确保在最坏情况下也能保持良好的性能。

5.typedef和define的区别：
    （1）用法不同：
        typedef用来定义一种数据类型的别名，提高程序的可读性
        define主要用来定义常量，以及书写复杂但是频繁使用的宏
    （2）执行时间不同
        typedef是编译的一部分，有类型检查的功能
        define是宏定义，是预编译的一部分，发生在编译之前，只进行简单的字符串替换，而不进行类型检查
    （3）作用域不同：
        typedef有作用域限制 当typedef出现在函数体内，其作用域也仅限于函数体内
        define没有作用域的限制  
    （4）代码编写语法不同：
        typedef定义是语句，末尾需要加分号

6.指针传递和引用传递的区别
    （1）语法和用法：
        指针传递：需要使用 * 来定义指针，调用时通常需要解引用，例如 *ptr。
        引用传递：使用 & 定义引用，调用时可以像普通变量一样使用，无需解引用。
    （2）空值处理：
        指针传递：可以传递 nullptr，表示指针不指向任何对象。
        引用传递：必须始终引用一个有效的对象，不能为 null。
    （3）重指向能力：
        指针传递：可以在函数内改变指针的指向。
        引用传递：引用一旦绑定到一个对象后，无法再改变引用的对象。

7.main函数执行之前 还会执行什么代码
    （1）全局和静态变量初始化：
        在进入 main 函数之前，程序会初始化所有的全局变量和静态变量。全局变量和静态变量会被初始化为默认值（例如，基本数据类型会初始化为零），或者使用它们的初始化值。
    （2）构造函数调用：
        如果有全局对象或静态对象的构造函数，这些构造函数会在 main 函数执行之前被调用。顺序上，全局对象的构造函数会按照它们在代码中出现的顺序执行。
    （3）动态库初始化，C++标准库的初始化

8.C++程序编译过程
    （1）预处理器处理所有的指令，如 #include 和 #define，生成一个中间文件。可以使用命令：
        g++ -E example.cpp -o example.i 
        生成的 example.i 文件包含了所有的头文件内容和宏替换。
    （2）将预处理后的代码转换为汇编语言。可以使用命令：
        g++ -S example.cpp -o example.s
        生成的 example.s 文件是汇编代码。
    （3）将汇编代码转换为机器代码，生成目标文件。可以使用命令：
        g++ -c example.cpp -o example.o
        生成的 example.o 文件包含机器码，但还不是可执行文件。
    （4）将目标文件与标准库链接，生成最终的可执行文件。可以使用命令：
        g++ example.o -o example

9.shared_ptr是线程安全的吗？
    引用计数的修改（如 shared_ptr 的复制和销毁）是线程安全的。
    访问共享对象（即通过 shared_ptr 操作实际对象的内容）则 不是线程安全的，需要外部同步。

10.堆栈跟踪：使用 backtrace 捕获崩溃时的堆栈信息。
    1. 什么是堆栈跟踪？
        在程序执行过程中，计算机系统通过堆栈（stack）来管理函数的调用。当一个函数被调用时，它的执行环境（如局部变量、返回地址等）被推送到堆栈中，函数执行完毕后，这些信息会从堆栈中弹出。
        堆栈中的信息按照后进先出（LIFO）的顺序组织。当程序发生崩溃时，堆栈跟踪就展示了崩溃时的调用历史，从而帮助我们了解在崩溃时是通过哪些函数调用到达崩溃点的。
    2.为什么堆栈跟踪有用？
        堆栈跟踪是定位崩溃和调试程序问题的关键工具。通过查看堆栈信息，你可以：
            定位崩溃点：查看程序崩溃时在哪个函数或代码行。
            追踪调用路径：了解程序是如何通过不同的函数调用到达崩溃位置的。
            找到错误源头：通过分析堆栈中的函数调用顺序，找出是哪个函数的错误引起了崩溃。
    3.如何捕获堆栈跟踪？
        在 C++ 程序中，你可以通过标准库函数 backtrace 来获取堆栈跟踪。
        使用 backtrace 捕获堆栈跟踪
            backtrace 是 GNU 库提供的一个函数，它可以获取当前程序的调用栈信息。这个函数会返回一个指向程序调用栈中所有函数的指针数组。
            函数原型：
            #include <execinfo.h>
            void *backtrace(void **buffer, int size);
            buffer：这是一个指向指针数组的指针，backtrace 会将调用栈的地址填充到这个数组中。
            size：指定 buffer 数组的大小，决定了 backtrace 可以记录多少个函数调用信息。
    总结：
        堆栈跟踪提供了程序崩溃时的函数调用路径，帮助开发者快速定位问题。
        使用 backtrace 捕获堆栈信息，再用 backtrace_symbols 解析和打印可读的符号信息。
        输出的堆栈信息包含函数名、偏移量、内存地址等，有助于定位程序崩溃的具体位置。
        在编译时开启调试信息，使堆栈跟踪更具可读性，能直接关联到源代码。

11.在C++使用tcp进行网络传输大文件时，在客户端传输的过程中 网络断开了，过了一段时间才恢复，这时候 传文件的情况是什么样的
    TCP 作为一种面向连接的协议，会提供一些机制来处理网络中断和恢复的情况，但具体行为会依赖于许多因素，比如 TCP 的重传机制、超时设置、缓冲区大小等。
    1.网络断开时的行为
        TCP 重传机制：
            当网络断开时，TCP 会检测到连接中断或没有收到对方的确认（ACK）。在这种情况下，TCP 会尝试重新连接并通过重传机制发送丢失的数据。
            重传的过程是透明的，客户端和服务器端通常都不需要主动干预。
        TCP 保持连接状态：
            网络恢复时，TCP 会尽可能地恢复原来的连接。服务器会等待客户端重试，客户端会通过重传丢失的数据来恢复传输
        超时与重传：
            如果网络中断时间过长，TCP 会超时。默认情况下，TCP 会经过若干次重传尝试（通常是 5 次）。
            如果超时超过最大重传次数，连接会被关闭。此时，客户端和服务器都可能会发现连接已断开，程序需要处理连接重建或错误恢复的逻辑。
        TCP 缓冲区：
            当传输的数据还没有被成功传输到对方时，它会存在 TCP 的发送缓冲区中，直到网络恢复。这意味着，如果网络中断期间客户端一直在发送数据，而网络恢复后，TCP 会重新将缓冲区中的数据传输到对方

12.在上面情况上使用new或者malloc
    1.何时使用new
        需要创建对象并希望自动调用构造函数时
        希望内存分配失败时能够抛出异常处理情况
        希望在释放是能够自动调用析构函数来清理资源
    2.什么时候使用malloc    
        只需要原始内存块不关心构造函数和析构函数时
        不需要类型安全并且不需要构造函数初始化时

13.memset
    1.对于只包含基本类型或固定大小数组的对象，可以直接使用memset来初始化
    2.对于包含指针或其他需要动态分配的对象，应该使用构造函数和初始化列表来确保正确的初始化
    3.直接使用memset清零包含指针的对象可能会导致未定义行为

    普通没有虚函数的类，我们都知道普通类对象会隐含一个this指针，那么是否可以使用memset呢？
        没有虚函数的类 可以使用 memset 来操作内存，但需要确保不破坏对象的内部状态。
        对于包含指针或动态分配内存的类，使用 memset 时要小心，它可能会破坏指针的有效性，导致资源泄漏或悬挂指针。
        memset 最适用于那些没有动态资源管理（例如，没有指针成员）的简单数据结构。对于需要复杂内存管理的类，最好避免使用 memset，而采用合适的构造函数、析构函数和复制控制。

14.vector的元素类型可以是引用吗？
    vector的底层实现是要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。
    std::vector 是一个非常灵活的容器，它的元素类型可以是：
        基本类型（如 int、char、double 等）
        用户定义的类型（如 struct、class 等）
        指针类型（如 int*、double* 等）
        其他模板类型（如 std::pair、std::tuple 等）
        容器类型（如 std::vector<int>、std::map 等）
        智能指针类型（如 std::unique_ptr、std::shared_ptr 等）
        函数指针或 std::function 类型
        std::variant 类型（用于存储不同类型）
    虽然 C++ 不允许 std::vector 存储引用类型（因为引用本质上不是一个对象，它必须绑定到一个有效的对象），但是你可以通过指针来间接存储引用。
        int a = 5;
        int b = 10;
        std::vector<int*> vec7 = {&a, &b};  // 存储整数的指针

15.正确释放vector的内存（clear() sawp() shrink_to_fit()）
    vec.clear():清空内容，但是不释放内存
    vector().swap(vec):清空内容，且释放内存
    vec.shrink_to_fit():请求容器降低其capacity和size匹配

16.map的插入方式有哪几种？
    1. 用insert函数插入pair数据，
        mapStudent.insert(pair<int, string>(1, "student_one"));
    2.用insert函数插入value_type数据
        mapStudent.insert(map<int, string>::value_type (1, "student_one"));
    3.在insert函数中使用make_pair()函数
        mapStudent.insert(make_pair(1, "student_one"));
    4.用数组方式插入数据
        mapStudent[1] = "student_one"; 

17.map 、set、multiset、multimap的底层原理
    map 、set、multiset、multimap的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树。
    元素特点：
        1.set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。
        2.map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。
    为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？
        因为存储的是结点，不需要内存拷贝和内存移动。
        因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

18.STL的各个容器的迭代器在什么情况下失效？
    std::vector	插入或删除元素（尤其是在中间），尤其是扩展时
    std::deque	插入或删除中间元素时，扩展时可能会失效
    std::list	删除当前元素会使迭代器失效，插入不失效
    std::map / std::set	删除当前元素会使迭代器失效，插入不失效
    std::unordered_map / std::unordered_set	删除当前元素会使迭代器失效，扩展时可能失效
    std::stack / std::queue	不支持迭代器，不能直接遍历
    std::array	不会失效，大小固定
    std::priority_queue	不支持迭代器，不会失效

