C++ 部分笔记

1.Map扩容是怎么做到的？
答：std::map 是一个基于红黑树的关联容器，它的扩容过程与 std::vector 等动态数组容器的扩容有所不同。
    std::map 使用红黑树来存储键值对。在插入新元素时，它会根据键的顺序将元素插入到树中。
    因为红黑树的结构是动态的，它可以根据需要自动调整和扩展，而不需要像数组那样进行“扩容”。
        map的插入操作：
        通过比较键值找到正确的插入位置。
        创建一个新的节点，并将其链接到树中。
        可能会进行旋转操作以维持红黑树的性质。

2.HashMap扩容机制，为什么每次扩容两倍？
答：达到某个阈值时，能够保持良好的性能，主要体现在插入和查找操作的时间复杂度
    当元素数量超过桶数的 75% 时，HashMap 会触发扩容
     为什么扩容两倍?
     (1)减少冲突：通过将桶的数量翻倍，可以有效地减少哈希冲突
     (2)性能优化：扩容后，查找和插入操作的平均时间复杂度可以保持在 O(1)
     (3)空间效率：扩容到两倍的大小通常能够在一定程度上保持负载因子在可接受范围内，减少频繁扩容带来的性能开销

3.线程的run()和start()有什么区别？
    （1）run() 方法：
        作用：run() 方法是线程的执行体，包含了线程执行时要执行的代码。如果你直接调用 run() 方法，它只是作为普通方法执行，而不会创建新线程。
        线程状态：调用 run() 方法不会改变线程的状态，它会在调用它的线程（通常是主线程）中执行。
        示例：如果你直接调用 run()，则不会实现并发，而是顺序执行。
    （2）start() 方法
        作用：调用 start() 方法会启动一个新线程。它会调用 run() 方法，但这个过程是在新线程中执行的。
        线程状态：当 start() 被调用时，线程会从“新建”状态变为“就绪”状态，等待操作系统调度来执行。
        示例：你可以通过调用 start() 来并行执行任务。

4.C++为什么HashMap链表要转为红黑树?
    在 C++ 的 std::unordered_map 中，当桶内的链表长度超过一定阈值时，链表可以转化为红黑树。这种设计主要是为了提高性能，特别是在处理哈希冲突的情况下。以下是几个主要原因:
    (1)查找效率 
        性能改善：链表的查找时间复杂度是 O(n)，而红黑树的查找时间复杂度是 O(log n)。在存在大量冲突时，转化为红黑树可以显著提升查找效率。
    (2)冲突管理
        冲突处理：当多个元素映射到同一个桶中，链表会增长。如果链表过长，性能会受到影响。通过将链表转换为红黑树，能够有效控制冲突带来的性能下降。
    (3)自平衡特性
        红黑树的自平衡：红黑树是一种自平衡的二叉搜索树，插入和删除操作后会自动调整，以保持 O(log n) 的高度。这可以确保在最坏情况下也能保持良好的性能。

5.typedef和define的区别：
    （1）用法不同：
        typedef用来定义一种数据类型的别名，提高程序的可读性
        define主要用来定义常量，以及书写复杂但是频繁使用的宏
    （2）执行时间不同
        typedef是编译的一部分，有类型检查的功能
        define是宏定义，是预编译的一部分，发生在编译之前，只进行简单的字符串替换，而不进行类型检查
    （3）作用域不同：
        typedef有作用域限制 当typedef出现在函数体内，其作用域也仅限于函数体内
        define没有作用域的限制  
    （4）代码编写语法不同：
        typedef定义是语句，末尾需要加分号

6.指针传递和引用传递的区别
    （1）语法和用法：
        指针传递：需要使用 * 来定义指针，调用时通常需要解引用，例如 *ptr。
        引用传递：使用 & 定义引用，调用时可以像普通变量一样使用，无需解引用。
    （2）空值处理：
        指针传递：可以传递 nullptr，表示指针不指向任何对象。
        引用传递：必须始终引用一个有效的对象，不能为 null。
    （3）重指向能力：
        指针传递：可以在函数内改变指针的指向。
        引用传递：引用一旦绑定到一个对象后，无法再改变引用的对象。

7.main函数执行之前 还会执行什么代码
    （1）全局和静态变量初始化：
        在进入 main 函数之前，程序会初始化所有的全局变量和静态变量。全局变量和静态变量会被初始化为默认值（例如，基本数据类型会初始化为零），或者使用它们的初始化值。
    （2）构造函数调用：
        如果有全局对象或静态对象的构造函数，这些构造函数会在 main 函数执行之前被调用。顺序上，全局对象的构造函数会按照它们在代码中出现的顺序执行。
    （3）动态库初始化，C++标准库的初始化

8.C++程序编译过程
    （1）预处理器处理所有的指令，如 #include 和 #define，生成一个中间文件。可以使用命令：
        g++ -E example.cpp -o example.i 
        生成的 example.i 文件包含了所有的头文件内容和宏替换。
    （2）将预处理后的代码转换为汇编语言。可以使用命令：
        g++ -S example.cpp -o example.s
        生成的 example.s 文件是汇编代码。
    （3）将汇编代码转换为机器代码，生成目标文件。可以使用命令：
        g++ -c example.cpp -o example.o
        生成的 example.o 文件包含机器码，但还不是可执行文件。
    （4）将目标文件与标准库链接，生成最终的可执行文件。可以使用命令：
        g++ example.o -o example