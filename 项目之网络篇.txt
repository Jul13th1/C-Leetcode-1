1.线程池的作用？
    主要作用：避免创建过多的线程时引发的内存溢出问题，因为创建线程是非常耗内存的
    1.降低资源消耗：通过重复利用已创建的线程减低线程创建和销毁造成的消耗。
    2.调高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行
    3.提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
    如果线程的并发数量过多，线程之间抢占所属进程资源的情况就很严重，容易导致阻塞，使用线程池能有效的控制线程的最大并发数，有效避免阻塞问题。
    什么时候使用线程池？
        a.单个任务处理时间较短
        b.需要处理的任务数量大
    什么时候不适宜用线程池？
        a.线程执行需要很长的时间
        b.需要为线程指定详细的优先级，因为线程池都是基于任务队列来排队，先来先执行
        c.在执行线程中需要对线程进行操作，比如睡眠挂起等，因为线程池本身就是为了突然大量爆发的短任务而设计

2.如何实现线程池？
    1.创建线程池控制结构的结构体
    2.初始化线程池：
        线程池空间开辟+信息初始化+初始化互斥锁和条件变量+创建线程
    3.向线程池的任务队列中添加一个任务：
        上锁+判断线程池状态（队列满的时候就等待、队列关闭或者线程池关闭就退出、队列空的时候，有任务来时就通知线程池中的线程）+解锁
    4.任务执行（回调函数）
        上锁+判断线程池状态（队列为空时就等待、线程池关闭就退出、队列非满：添加新任务、队列为空：销毁线程函数）+解锁+线程真正要做的工作，回调函数的调用。

3.聊天室的服务器框架？
    主线程监听socket之后，进入无限循环调用accept处理客户端的连接，accept返回新的客户端socket后封装任务交给线程池处理，线程池的线程共用一个队列
    当有任务产生时，从任务队列中取出执行。
问题：
4.主线程如何通知工作线程有任务？
    使用条件变量，并且每次只唤醒一个工作线程
5.C++使用线程池时，假设某次投递了N个任务，想同时唤醒N个线程（N小于工作线程数目），这样如何设计？
    1.使用std::queue来储存任务
    2.线程池：使用 std::vector<std::thread> 来存储工作线程，线程池的线程数大于 N
    3.条件变量：用于线程之间的同步和唤醒。
    4，任务调度：在投递任务时，通过条件变量和任务计数器来控制唤醒 N 个线程

6.如果 accept 之后就将客户端 socket 封装成任务交给线程池处理，此时严格来说是没有任务需要执行的，因为客户端 socket 上不一定有数据需要收发，如果有数据需要收发，
任务线程如何处理？如果在工作线程中将客户端 socket 挂载到某 IO 复用函数上去，那么为了保证效率，这些任务就常驻线程池了，这样几个连接之后，线程池的所有线程都被占用了，无法继续处理其他任务了
    在accept()后，客户端的socket可能不会立即有数据要发，这时候将socket交给线程池的工作线程，线程可能会处于等待状态，直到有数据可读或者可写
    这种设计的核心是将 IO 复用的事件循环与工作线程池分开。你可以在主线程中使用 IO 复用机制（如 epoll 或 select）来监听所有的客户端 socket。然后，在有可读/可写事件发生时，将相应的任务交给工作线程池处理。
        设计步骤：
        主线程：使用 epoll 或 select 等机制监听所有的 socket（包括新接入的连接）。
        IO 事件通知：当某个 socket 上有可读/可写事件时，主线程将该 socket 和任务封装成一个工作任务。
        提交给线程池：主线程将任务提交给线程池，工作线程会在获取到任务后进行相应的处理。
        工作线程：处理实际的业务逻辑，如读取数据、处理请求并返回响应等。

7.TCP 是流式协议，包头可以通过 \r\n\r\n 确定边界，包体如何确定边界呢？
    固定长度包体：缺点可能需要填充一些无用的数据，以满足固定长度要求。
    长度字段方式：在包头中包含一个字段，指明包体的长度。接收方通过读取包头中的长度信息来确定包体的边界。缺点是需要额外的包头来存储长度信息
    分隔符方式：除了使用 \r\n\r\n 来分隔头部与包体，你也可以使用其他特定的分隔符（如 \0、|、$ 等）来分隔包体的不同部分
    消息边界协议（比如 \n 或 \0）：容易受到数据中出现分隔符的干扰，可能导致解析困难。

8.GET 请求和 POST 请求有什么区别？
    GET 请求：
        目的：GET请求常用于获取资源（如网页、图片、数据等）。它是无副作用的请求，意味着它不会修改服务器上的任何数据
        参数位置：在GET请求中，所有的请求参数都包含在URL中，即URL 后的查询字符串部分（如 ?key1=value1&key2=value2）。这些参数通过 & 符号分隔
        请求体：GET 请求没有请求体，所有数据都放在 URL 中。
        数据长度限制：由于所有数据都在 URL 中，浏览器或服务器对 URL 长度有一定限制（一般是 2048 字符左右），因此 GET 请求适合传递少量数据。
        缓存和历史记录：GET 请求可以被缓存，并且会记录在浏览器的历史记录中。
    POST请求：
        目的：POST 请求通常用于提交数据（如表单数据、文件上传等）到服务器，并可能修改服务器上的数据（例如创建、更新资源）。
        参数位置：POST 请求中的参数不包含在 URL 中，而是放在请求体（body）中。请求体的内容可以是各种格式，如表单数据、JSON、XML 或文件数据。
        请求体：POST 请求有请求体，可以承载大量数据，没有像 GET 请求那样的长度限制
        缓存和历史记录：POST 请求不会被缓存，也不会出现在浏览器的历史记录中。

9.如何区分GET和POST请求？
    在服务器处理请求时，通常会根据 HTTP 请求的 方法 来区分 GET 和 POST 请求。服务器在解析 HTTP 请求时，会检查请求的 Method 字段：
	GET 请求：Method: GET
	POST 请求：Method: POST
     这两种请求方法有不同的处理流程：
	GET 请求：一般直接解析 URL 中的查询参数（query string）。
	POST 请求：解析请求体中的数据。

10. 如何解包 GET 请求和 POST 请求的数据？
    GET请求数据包解包：
        GET 请求的数据通常通过 URL 查询字符串传递，因此解包 GET 请求的数据主要是从 URL 中解析查询字符串。
    POST 请求数据解包：
        POST 请求的数据则通过请求体（body）传递，具体的数据格式取决于 Content-Type 头的值，
        常见的 POST 数据格式有 application/x-www-form-urlencoded、multipart/form-data 和 application/json 等。
        1.application/x-www-form-urlencoded：
	        这种格式通常用于表单数据，数据是键值对的形式，每个键值对由 & 分隔，并且键和值之间使用 = 连接
        2.multipart/form-data：
            这种格式通常用于上传文件，数据会被分割成多个部分，每个部分都有自己的头部信息和内容。每个部分用一个分隔符（boundary）分开。
            服务器解包时，需要根据 boundary 来分割请求体，提取文件内容及表单数据
        3.application/json：
	        当 POST 请求的 Content-Type 为 application/json 时，请求体的内容是一个 JSON 格式的字符串。服务器需要将请求体解析为 JSON 对象。

11.POST 请求的数据放在哪里，如何确定？
    POST 请求的数据存放在请求体（Body）中。
	在 HTTP POST 请求中，数据的长度可以通过 Content-Length 头部来确定。Content-Length 是一个 HTTP 请求头，它表示请求体中数据的字节数。
    它的作用是告知服务器，数据的总长度是多少，服务器可以根据这个长度读取正确数量的字节。

12.服务端需要调用 bind 一个端口号，如果不 bind 会怎样？客户端通常不需要 bind 一个端口号，但是如果调用 connect 函数前，我们调用 bind 函数绑定一个端口号，会怎样？
    如果不调用 bind：
		服务端无法知道通过哪个端口来接收来自客户端的连接请求。
		服务器无法监听和接收数据，因为没有明确的端口来接收客户端连接。
		在实际的程序中，通常在 bind 之后才会调用 listen 或 accept 等函数来处理客户端的连接
    简而言之，服务端必须调用 bind 来绑定端口，才能开始接收来自客户端的连接请求。
	客户端调用 bind 函数绑定端口号
	    客户端通常不需要手动调用 bind，因为在调用 connect 时，操作系统会自动为客户端分配一个本地端口。客户端通常只关心连接到服务端的远程地址和端口，不必关心本地端口的选择。
	    客户端如果显式地调用 bind 绑定了一个端口，它会将本地套接字绑定到指定的端口号上。
        通常情况下，客户端并不需要指定本地端口，因为操作系统会自动选择一个可用端口。
    调用 bind 绑定本地端口对客户端的影响：
        如果客户端明确调用了 bind，它将强制客户端使用指定的端口进行通信。
        如果客户端调用了 bind，它将始终使用指定的端口进行通信，而无论操作系统是否有更合适的端口。
	    如果绑定的端口已经被占用，bind 会失败，返回错误。





