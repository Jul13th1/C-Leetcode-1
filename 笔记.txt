IO多路复用，select、poll、epoll 的区别？
    1.select
        实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，
    检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用
    户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。

        所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，
        而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。
    select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。

    2.poll 
        不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。
        但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，
        时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。

    3.epoll
        通过两个方面，很好解决了 select/poll 的问题
        第一点：
            epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。
        而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有
        待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。
        第二点：
            epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，
        只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

执行顺序总结：
    1.创建 epoll 实例：
        调用 epoll_create 来创建一个 epoll 实例，返回 epoll 文件描述符。
    2.注册文件描述符：
        使用 epoll_ctl 注册或修改文件描述符，指定要监听的事件类型。
    3.等待事件发生：
        调用 epoll_wait 阻塞（或非阻塞）等待已注册文件描述符上的 I/O 事件发生，并处理返回的事件。
    总结：
    epoll_create：创建 epoll 实例，返回 epoll 文件描述符。
    epoll_ctl：将文件描述符和对应的事件注册到 epoll 实例中。
    epoll_wait：阻塞（或非阻塞）等待事件的发生，并返回准备好的文件描述符和事件。
    通过这种机制，单个线程可以高效地处理大量的并发连接，避免了每个连接都创建一个线程带来的性能和资源消耗。

epoll和线程对比：
    epoll 和线程是两种不同的并发处理机制，它们的工作原理、使用场景和性能特征各不相同
    1. 基本概念
        epoll：
            epoll 是 Linux 提供的一个 I/O 多路复用机制，用于处理大量的并发 I/O 操作。
            它允许单个线程在事件循环中监控多个文件描述符的 I/O 状态，从而实现高效的并发处理。epoll 通过非阻塞 I/O 和事件通知机制来管理大量的连接，避免了频繁的线程切换。
        线程：
            操作系统调度的基本单位，多个线程可以并发执行，甚至在多核 CPU 上同时运行。线程通常用于处理多任务并发，尤其是 CPU 密集型任务。
            每个线程都有独立的堆栈和执行上下文，线程间通过共享内存和同步机制进行通信。
    2. 工作原理
        epoll：
            1.epoll 通过在一个线程内使用事件循环，监听多个文件描述符（如 socket）的 I/O 事件。
            2.当某个文件描述符准备好 I/O 操作（如可读、可写、异常等）时，epoll 会通知程序进行处理。
            3.只有当某个事件发生时，程序才会处理该事件，避免了阻塞等待，节省了大量的资源。
        线程：
            1.每个线程都可以独立地执行任务。线程通常是阻塞的，除非使用非阻塞 I/O 或者线程内部的同步机制。
            2.线程可以并行执行任务，因此适合处理 CPU 密集型任务或需要独立状态的任务。
            3.每个线程都有自己的栈和寄存器上下文，因此线程切换开销较大。
    3. 使用场景
        epoll：
            适合 I/O 密集型任务，尤其是网络服务器需要处理大量并发的网络连接时。epoll 能够高效地处理大量的客户端连接，而不需要为每个连接都创建一个线程。
            常见的应用场景：高性能网络服务器（如 HTTP 服务器、数据库服务器等）、事件驱动的程序。
        线程：
            适合 CPU 密集型任务，如数据计算、图像处理、加密解密等。
            线程可以处理多个任务，并且能够利用多核处理器的并行能力。对于复杂的任务，多个线程可以同时处理不同部分，缩短整体执行时间。
            常见的应用场景：多核 CPU 下的并行计算、异步任务处理等。
    4. 性能和效率
        epoll：
            由于 epoll 是基于事件驱动的，它能够在一个线程中管理多个 I/O 操作，避免了线程上下文切换的开销，效率非常高。
            epoll 采用边缘触发（Edge Triggered）和水平触发（Level Triggered）两种模式，能够进一步减少不必要的事件通知和检查，提高性能。
            高效的 I/O 多路复用，适用于大规模并发连接（如 Web 服务器）。
            epoll 的缺点是它对 CPU 密集型任务不适用，因为它只处理 I/O 事件，无法充分利用多核 CPU 进行并行计算。
        线程：
            线程适合处理 CPU 密集型任务，可以利用多核 CPU 进行并行计算。
            线程的开销相对较大，尤其是在大量线程并发时，操作系统需要频繁地进行线程切换，这会增加额外的 CPU 和内存开销。
            使用线程时，通常需要同步机制来确保线程之间的共享数据一致性，这增加了复杂性和性能开销。
    5. 内存和资源消耗
        epoll：
            epoll 在使用时，通常只需要一个线程和少量的内存来管理多个文件描述符，内存和资源消耗较小。
            因为 epoll 是事件驱动的，它避免了每个连接都创建一个线程，从而节省了线程上下文切换的开销和线程栈的内存。
        线程：
            每个线程都有自己的栈空间和上下文，需要占用一定的内存。
            当有大量线程时，操作系统需要频繁进行线程调度和上下文切换，这会消耗更多的 CPU 时间。
            线程池可以用来优化线程管理，减少线程的创建和销毁开销，但如果并发线程数过多，仍然会面临性能瓶颈。
    6. 易用性和复杂性
        epoll：
            epoll 是事件驱动的编程模型，通常需要手动管理事件循环，处理文件描述符的读写操作。相比线程模型，epoll 的编程模型可能较为复杂。
            需要理解非阻塞 I/O 和事件通知机制，调试可能相对较困难。
        线程：
            线程模型更为直观，适合许多传统的编程任务。
            线程间通信和同步（如互斥锁、条件变量）是需要注意的难点，尤其是在多线程同时操作共享资源时，容易产生死锁和竞态条件。
    7. 扩展性
        epoll：
            epoll 非常适合扩展到大规模的网络应用，能够处理成千上万的并发连接。由于只使用少量线程（通常是一个），它的扩展性非常好。
            通过事件驱动和 I/O 多路复用，服务器可以在有限的资源下处理大量并发请求。
        线程：
            多线程模型在 CPU 密集型任务下表现较好，但线程数量过多时会面临线程调度开销、内存占用和线程管理的挑战。
            线程池可以在一定程度上改善线程管理，但在极高并发的情况下，仍然会遇到瓶颈。