function lambda bind 之间的关系
一.function类模版 是一个抽象了函数参数以及返回值的类模版
    到底是具体怎么抽象的？
    1.把任意函数包装成一个对象，该对象可以保存以及复制
    2.动态绑定，只需修改对象（赋值不同的function对象），实现类似多态的效果
    
    具体用途：
    1.保存普通函数，类的静态成员函数
    2.保存仿函数
    3.保存类成员函数
    4.保存lambda表达式

什么是仿函数？
    重载了操作符（）的类
    特征：可以有状态，通过成员变量进行储存状态
        有状态的成员函数称之为闭包

二.lambda表达式
    1.值捕获不能修改外部变量的值,可以在其（）函数后面加上mutable修改传进来的外部变量的值，函数结束之后，外部变量的值仍然不会被改变
    2.使用引用捕获时，外部和内部的值都会被修改
    原理：编译的时候，将lambda表达式转变为一个函数对象
        根据lambda参数列表重载operator()

三.bind函数适配器
    定义：用来通过绑定函数以及函数参数的方式生成函数对象的模版函数
    提供占位符，实现灵活绑定

    std::bind 在 C++ 中的典型应用
    1.与标准库算法配合使用 std::bind 可以和标准库算法配合使用，来绑定函数和算法所需的参数。
    2.与线程结合 std::bind 可以用来将一个函数与其参数绑定，并传递给线程，从而在后台执行

四.左值引用
    左值引用是指向一个左值的引用，左值是指在表达式中可以获取地址的值
    int x = 10;
    int &ref = x;  // ref 是 x 的左值引用
    左值（Lvalue）是指有持久地址的对象，通常是程序中的变量。
    左值引用通过 & 来定义，引用必须绑定到一个已经存在的对象。
    特点：
        1.可以被修改：左值引用可以改变所引用的对象的值（如果对象本身是可修改的）。
        2.必须引用已存在的对象：左值引用只能绑定到一个已存在的左值
五.右值引用：
    右值引用是指向一个右值的引用，右值是指那些不具有持久地址的值，通常是临时对象、字面量、计算结果等。
    int&& rref = 10;  // rref 是右值引用，绑定到 10
    右值（Rvalue）是临时对象，通常是表达式结果，无法获取其地址。
    右值引用通过 && 来定义。
    特点：1.可以修改临时对象：右值引用通常绑定到临时对象，允许直接操作或移动资源。
         2.可以用于移动语义：在 C++11 中，右值引用常常用来实现“移动语义”，即将资源从一个对象转移到另一个对象，而不是复制数据。
六.将亡值：Rvalue
    1.将亡值（Rvalue）指的是能够被“销毁”的对象。
      简单来说，右值就是将亡值。例如，std::move 就是一个将值转化为将亡值的工具。
    2.将亡值是指向临时对象或无法再使用的对象的引用，它通常表现为右值引用。
      将亡值的特殊性质使得它非常适用于移动语义。
    int&& rref = std::move(x);  // std::move(x) 转换 x 为将亡值
    使用 std::move 将一个左值转换为将亡值，意味着该对象的资源可以被“移动”到另一个对象，而不是被复制。
    特点：
    1.可以被“偷走”资源：将亡值通常用于实现“移动构造”和“移动赋值”。
    2.不会再使用：一旦一个对象成为将亡值，它的资源就可以被转移，不再对原对象的状态做任何假设。
七.完美转发：
    完美转发是指将一个函数的参数完美地转发到另一个函数，保持原有参数类型（左值或右值）不变
    代码示例：
    #include <iostream>
    #include <utility>

    void printValue(int& x) 
    {
        std::cout << "Lvalue: " << x << std::endl;
    }

    void printValue(int&& x) 
    {
        std::cout << "Rvalue: " << x << std::endl;
    }

    template <typename T>
    void forwardValue(T&& arg) 
    {
        printValue(std::forward<T>(arg));  // 完美转发
    }

    int main() 
    {
        int x = 10;
        forwardValue(x);         // 调用 printValue(int&)
        forwardValue(20);        // 调用 printValue(int&&)
        return 0;
    }
    完美转发的关键：
        使用 std::forward 来保持传入参数的类型（左值或右值）。
八.移动语义：
    移动语义允许我们将对象的资源从一个地方转移到另一个地方，而不是复制这些资源。避免不必要的复制开销
    移动构造函数和移动赋值操作符
        移动构造函数：使用右值引用构造新对象时，从另一个对象“窃取”资源。
        移动赋值操作符：使用右值引用将资源从一个对象转移到另一个对象。
    代码示例：
    #include <iostream>
    #include <vector>

    class MyClass 
    {
    public:
        MyClass() { std::cout << "Default constructor\n"; }
        MyClass(MyClass&& other) { std::cout << "Move constructor\n"; }
        MyClass& operator=(MyClass&& other) 
        {
            std::cout << "Move assignment\n";
            return *this;
        }
    };
    
    int main() 
    {
        MyClass obj1;
        MyClass obj2 = std::move(obj1);  // 移动构造
        obj2 = std::move(obj1);           // 移动赋值
        return 0;
    }
    移动构造函数：MyClass(MyClass&& other) 通过右值引用将 other 的资源移动到新创建的对象。
    移动赋值操作符：operator=(MyClass&& other) 通过右值引用将资源从 other 转移到当前对象

    总结：
        左值引用：绑定到左值，可以修改对象的值。
        右值引用：绑定到右值或临时对象，支持移动语义。
        将亡值：是可以转移资源的右值，通过 std::move 将左值转换为右值引用。
        完美转发：保持传入参数的类型（左值或右值）不变，使用 std::forward 来完美转发参数。
        移动语义：允许对象资源的转移，而不是复制，减少不必要的资源开销。

九.为什么 C++ 类型别名更推荐使用 using 而非 typedef？
    1.using可以定义模版类型别名，typedef不行

十.内联函数特点
    1.内敛函数的内容会直接替代调用它的代码位置
    inline int add(int a, int b) 
    {
        return a + b;
    }
    int main() 
    {
        int result = add(5, 3); // 这里编译器会把 `result = add(5, 3)` 替换为 `result = 5 + 3`
    }
    在编译阶段，内联函数的代码会直接替换掉用内联函数的地方
    2.执行时不需要进入函数过程，直接运行函数体
    inline void printHello() 
    {
        std::cout << "Hello, World!" << std::endl;
    }

    int main()
    {
        printHello(); // 这里会直接替换为 `std::cout << "Hello, World!" << std::endl;`
    }
    因为内联函数的代码已经在编译时插入，所以在运行时不需要函数调用过程。
    3.类似宏具有类型检查的功能，保留了函数的特性
    #define SQUARE(x) ((x) * (x))
    inline int square(int x) 
    {
        return x * x;
    }

    int main() 
    {
        std::cout << SQUARE(5) << std::endl; // 宏展开后为 `((5) * (5))`
        std::cout << square(5) << std::endl; // 内联展开后为 `5 * 5`
    }
    内联函数与宏类似，但不同的是，内联函数有类型检查，确保类型安全
    4.编译器通常不会内联包含循环、递归、switch 等复杂操作的函数
    inline int factorial(int n) 
    {
        if (n <= 1) return 1;
        return n * factorial(n - 1); // 编译器可能不会内联这个递归函数
    }
    编译器对复杂函数的内联有一定限制，不会内联包含复杂逻辑的函数。
    5.在类声明中定义的非虚函数会自动被视为内联函数
    在类的声明中定义的非虚成员函数，编译器会自动将其视为内联函数。

    优点：
    1.避免了参数压栈、栈帧操作和返回值处理，提高运行速度
        inline int multiply(int a, int b) 
        {
            return a * b; // 直接展开到调用点，避免函数调用开销
        }
        通过内联展开，减少了函数调用的开销，如参数传递、栈操作等。
    2.相比宏函数，内联函数具有类型安全
    #define MAX(a, b) ((a) > (b) ? (a) : (b)) // 没有类型检查
    inline int max(int a, int b) 
    {
        return a > b ? a : b; // 有类型检查
    }
    内联函数在展开时会进行类型检查，确保类型安全，而宏定义不会。
    3.内联函数可以访问类的成员变量
        在类中声明并定义的内联函数，可以访问类的成员变量，而宏定义不能。
    4.内联函数在运行时可以调试
        inline void debugPrint(int x) 
        {
            std::cout << "Value: " << x << std::endl; // 可以在此设置断点
        }
        内联函数依然保留了函数的特性，可以在调试时设置断点，而宏定义不行。
    缺点：
    1.代码膨胀
        由于内联函数每次调用时都复制代码，可能会导致代码膨胀，增加程序的代码量和内存消耗。
    2.无法随库的升级而升级
        内联函数的修改需要重新编译整个程序，不像非内联函数可以直接链接更新。
    3.是否内联由编译器决定
        内联函数只是对编译器的建议，最终是否内联由编译器决定，程序员无法强制。
