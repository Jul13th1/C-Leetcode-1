TCP/IP协议栈
OSI七层网络模型：
（1）应用层：所有能和用户交互产生网络流量的程序，应用程序使用（主要协议FTP（文件传输）、HTTP、SMTP（电子邮件）））
（2）表示层：文件格式，用于处理在两个通信系统中交换信息的表示方式
（3）会话层：控制发包的数据，向表示层实体/用户进程提供建立连接并在连接上有序的传输数据
（4）传输层：负责主机中两个进程的通信，即端到端的通信 传输单位：报文段和用户数据报
（5）网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务 传输单位：数据报
（6）数据链路层：主要任务把网络层传下来的数据报组成帧 传输单位：帧
（7）物理层：通信介质的信号的物理信号 传输单位：bit
TCP/IP四层网络模型
（1）应用层：应用之间沟通的层次：FTP、HTTP
（2）传输层：进程和进程之间的通信 TCP UDP
（3）网络层：对数据进行打包传送的层 IP ICMP
（4）链路层：数据帧的发送

大端：高位放低地址
小端：地委放低地址
htonl：将32位主机字节序转成网络字节序
htons：将16位主机序列转成网络序列
udp和tcp区别
一、共同点：都是传输层协议
二、区别：
    1.是否面向连接
    udp：面向无连接的
    （1）无需三次握手，四次挥手
    （2）支持一对一，一对多，多对一，多对多
    tcp：面向连接的
    （1）三次握手建立连接，四次挥手断开连接
    （2）端对端连接
    （3）全双工允许两端同时发数据

    2.数据传输方式：
    udp：
        基于报文传输，在udp这一层不会进行分段，所以每次收发都是完整的报文
    tcp：
        基于字节流
        发送数据到socket的时候，它经过tcp，如果数据大于MSS（MSS代表“最大报文段长度”（Maximum Segment Size），它是TCP连接中可以发送的最大数据量，
        不包括TCP头和IP头。MSS的设置有助于避免在网络中发生分片，提升传输效率，MSS1500减去ip头20减去tcp头20，所以通常大小为1460字节，所以数据包大于
        这个字节的时候，就可能会拆分成多个tcp报文段，不会保留用户层数据包的一个边界，对于接收方而言需要处理粘包问题，怎么处理：用户层会根据根据特殊字符
        界定一个完整的数据包将它取出来），就会进行分段，分段之后，在ip层如果大于MTU还会进行分片
        什么是MTU：MTU代表“最大传输单元”（Maximum Transmission Unit），是指在网络层（如IP层）中，能够通过网络传输的最大数据包大小，包括所有的协议头（如IP头）和数据部分。
    3.是否可靠：
    udp：不可靠传输
    （1）不保证信息交互
    （2）不保证交互顺序
    （3）不进行拥塞控制
    （4）不进行流量控制（没有接收缓冲区）
    tcp：可靠传输
    （1）tcp分段，进行发送数据包的控制
    （2）序列号（每个tcp报文都包含序列号，确保完整接收，丢失重复数据，将拆分的报文进行排序）
            为什么需要序列号：为了后面的数据包确认（确认应答机制）
            为什么三次握手需要随机序列号：防止三次握手前面的连接干扰当前连接的建立
    （3）确认应答机制：确认数据包收到
    （4）校验：检测报文在传输的过程中的数据发生变化
    （5）滑动窗口：主要作用实现流量控制，防止丢包
    （6）拥塞机制：指网络环境发生了拥塞，应该减少数据量的发送（如果忽略拥塞控制，就会一直不断的往这个网络环境中发送数据，可能会造成丢失数据包，从而进行重传）
    （7）超时重传
   4.传输效率：
   udp：效率高
   （1）不可靠传输
   （2）udp头8个字节
   tcp：效率低
   （1）tcp可靠传输，造成性能损失
   （2）tcp头20个字节
        tcp数据段比udp数据段高一些，所以传输效率没有udp高

网络编程问题汇总：
1.127.0.0.1，localhost和本机IP三者的区别？
    127.0.0.1环回地址：流向该地址的数据是不经过网卡的，所以在没有网络的状态下也能产生连接
    localhost 一个域名，通常被指向本地回环地址
    本机 IP 地址就是联网时使用的网卡分配到的 IP 地址。
2.一个完整的HTTP请求过程。
    1.域名解析
    2.发起tcp的三次握手
    3.发起tcp连接后发起http请求
    4.服务器端响应http请求，浏览器得到html代码
    5.浏览器解析html代码，并请求html代码中的资源
    6.浏览器对页面进行渲染呈现给用户
3.GET和POST请求方式的区别：
    GET：                           POST
    后退按钮/刷新无害                 数据会被重新提交
    数据长度限制/URL长度2048字符       长度无限制
    数据可见/安全性差                 不可见/更安全
    可以被缓存                       不可以被缓存

4.客户端端口可以重复使用吗？
    在tcp连接的初始阶段，客户端必须选择一个端口号，用以向服务器发起连接请求，客户端在执行connect函数的时候，会在内涵==内核里随机选择一个端口，
    然后向服务器发起SYN报文，然后与服务器进行三次握手

5.客户端connect服务器，但是ip写错了，会发生什么？
    1.ARP请求（局域网内）：
    如果错误的IP地址被分配到本地局域网内，客户端会首先尝试通过ARP请求获取该IP地址对应的MAC地址
    如果没有设备响应ARP请求，客户端会认为该IP地址在网络中不可达
    2.TCP尝试连接：
    如果客户端使用TCP协议尝试连接，它会开始TCP三次握手过程，发送SYN包。如果错误的IP地址不可达，客户端不会收到预期的SYN-ACK响应。
    客户端会根据 tcp_syn_retries 参数重试发送SYN包。在重试次数耗尽后，客户端会认为连接尝试失败，并向应用程序报告错误，通常是 “Connection timed out”。 

6.accept的作用？
    1.半连接队列：用于存放那些已经完成TCP三次握手的前两个步骤（客户端发送SYN包，服务器回复SYN+ACK包）的连接请求。
                此时处于SYN_RECEIVED状态，但尚未完成第三次握手（客户端发送ACK确认）。
        作用：服务器通过维护这样的一个队列来跟踪等待完成握手的连接，确保不会因为短时间内大量连接请求而丢失或混淆
    2.全连接队列：全连接队列是指那些已经完成了TCP三次握手，即客户端发出了最后一个ACK包确认，
                但服务器还未通过accept()系统调用将其取出并分配给进程处理的连接。这些连接的状态为ESTABLISHED。
        作用：这个队列保证了即便服务器端的进程暂时没有调用accept()来处理新连接，
             客户端与服务器之间的连接也能保持，直到被应用程序处理

7.TCP为什么是三次握手？而不是两次、四次？
    为什么不是两次？
        1.防止无用的连接的建立
         如果客户端因为网络延迟收不到ACK，一直重发SYN，
         服务端每收到一个SYN就只能先主动建立一个连接，将会造成很多重复的无效的连接
        2.过滤历史连接
        3.需要同步初始序列号
        TCP是全双工通信，其实本质上全双工通信是需要4次握手的，不过由于第2次和第3次可以合并成一次，所以就成了三次握手

8.TCP粘包的原因？
    1：TCP协议的流式特性 TCP本身对于发送的数据包就是当做一串无结构的字节流。
    2：Nagle算法  该算法会等待收集一定量的小数据包，合并成一个大的数据包再发送，以减少网络中的小包数量，这可能导致原数据包边界消失。
    3：接收缓冲区处理  接收方可能由于处理速度不及接收速度，导致多个数据包累积在缓冲区中，当从缓冲区读取数据时，可能会一次性读到多个数据包的内容。

9.TCP为什么要拆包？
    1. MTU（最大传输单元）限制
    2. MSS（最大段大小）协商
    3. 提高网络效率
    4. 流量控制
    5. 拥塞控制
    怎么解决TCP粘包问题？
        需要再应用层设计相应的协议来定义数据包的边界
    1.定长消息
        每个消息的大小固定，接收方按照预定长度读取消息。
    2.消息头
        在每个消息前添加包含消息长度的信息，接收方先读取消息头获取长度，再根据长度读取消息体。
    3.分隔符
        在消息之间使用特定的分隔符，接收方通过识别分隔符来拆分

10.拔掉网线后，TCP连接还在不在？
    1.有数据传输：
        客户端拔网线后，服务端发数据无响应，引发重传机制
        客户端重连发送数据，因服务端端口无匹配连接，将以RST响应，客户端接收到后关闭连接，最终双侧TCP连接均告终
    2.没有数据传输：
        如果没有开启 TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。
        而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文来确定对方的 TCP 连接是否存活;

11.TIME_WAIT状态的作用是？
    1.保证双方都能正确关闭
        如果没有TIME_WAIT状态的话，客户端最后一次发送ack应答报文后就进入了close阶段。
        如果服务端没有收到ack报文的话，就会重传FIN报文，而此时客户端已经close了，就会返回一个RST错误报文。
    2.防止错误的历史报文

12. TCP 连接建立时使用 随机序列号 的主要原因是 安全性和防止连接劫持
    1. 防止重放攻击
    2. 防止预测序列号（序列号碰撞）
    3. 防止序列号重复

13.为什么Time_Wait状态需要持续2MSL?
    1.2MSL就是一个发送报文和一个回复报文所需要的最大时间，
      如果直到2MSL，客户端没有再次收到FIN，那么客户端认为服务端已经收到了ACK，则结束TCP连接。
    2.客户端要保证第四个数据包（最后一个ACK包）能被服务器收到，怎么保证呢？就是通过等待 2MSL，第四个数据包传递到服务器需要 1 MSL，
      如果中间丢失了，服务器就会再发送第五个数据包（重传FIN）去让客户端重新发第四个包，这第五个包传递到客户端又需要 1MSL 时间。
      所以客户端为了确保第四个数据包能被服务器收到，就要等待 2MSL 时间。
    注意：客户端收到重传的FIN会重置Time_Wait的时间。

14.现在客户端不知道第三次握手丢失，在第二次握手后，客户端就立马给服务端发送了数据包，服务端会怎么处理？
    1.在第三次握手未完成的情况下，服务器进入 半开连接 状态，在此状态下，服务器已经发送了 SYN-ACK 包，等待客户端发送 ACK 包以完成三次握手。但在三次握手完成前，服务器 不认为连接已经完全建立
    2.收到客户端的数据包：
        a.服务器会首先检查该数据包的序列号和连接状态
        b.因为连接还没有完全建立（第三次握手尚未完成），服务器会拒绝该数据包或丢弃该数据包，通常会发送一个 RST（复位）包，告知客户端连接不可用，或者直接丢弃不做处理。
        c.服务器会向客户端发送一个 RST（Reset）包，表示当前的连接请求未完成，无法继续处理数据。
        d.客户端收到 RST 包后，会知道连接没有建立，通常会放弃发送数据，并可能重试连接（例如重新发送 SYN 包）。
        
